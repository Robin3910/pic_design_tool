# 频繁登录问题分析报告

## 问题概述

用户反馈系统频繁要求重新登录，影响用户体验。本文档结合前端和后端代码，分析可能的原因并提供解决方案。

## 后端代码分析

### 1. Token刷新逻辑（OAuth2TokenServiceImpl.java）

**关键代码位置**：`refreshAccessToken` 方法（第72-100行）

```java
public OAuth2AccessTokenDO refreshAccessToken(String refreshToken, String clientId) {
    // 查询刷新令牌
    OAuth2RefreshTokenDO refreshTokenDO = oauth2RefreshTokenMapper.selectByRefreshToken(refreshToken);
    if (refreshTokenDO == null) {
        throw exception0(GlobalErrorCodeConstants.BAD_REQUEST.getCode(), "无效的刷新令牌");
    }
    
    // 已过期的情况下，删除刷新令牌
    if (DateUtils.isExpired(refreshTokenDO.getExpiresTime())) {
        oauth2RefreshTokenMapper.deleteById(refreshTokenDO.getId());
        throw exception0(GlobalErrorCodeConstants.UNAUTHORIZED.getCode(), "刷新令牌已过期");
    }
    
    // 创建新的访问令牌
    return createOAuth2AccessToken(refreshTokenDO, clientDO);
}
```

**关键发现**：
- 刷新Token时会检查refreshToken是否过期
- 如果refreshToken过期，会删除并抛出异常
- 新的accessToken过期时间由 `clientDO.getAccessTokenValiditySeconds()` 决定

### 2. Token过期时间配置

**关键代码位置**：`OAuth2TokenServiceImpl.java` 第167行和第179行

```java
// AccessToken过期时间
.setExpiresTime(LocalDateTime.now().plusSeconds(clientDO.getAccessTokenValiditySeconds()));

// RefreshToken过期时间
.setExpiresTime(LocalDateTime.now().plusSeconds(clientDO.getRefreshTokenValiditySeconds()));
```

**问题**：Token过期时间由数据库中的 `system_oauth2_client` 表配置，需要检查：
- `accessTokenValiditySeconds`：访问令牌有效期（秒）
- `refreshTokenValiditySeconds`：刷新令牌有效期（秒）

## 前端代码分析

### 1. Token刷新机制（tokenRefreshManager.ts）

**当前实现**：**被动刷新机制**
- 只在收到401错误时触发刷新
- 没有主动在Token过期前刷新
- 如果refreshToken也过期，会跳转到登录页

**关键代码**：
```typescript
// 处理 401 错误并刷新 token（被动刷新机制）
export async function handle401Error(config: any, service: any): Promise<any> {
    // 只在收到401时才刷新
    if (!isRefreshing) {
        const refreshTokenRes = await refreshToken()
        // ...
    }
}
```

### 2. 缺少主动刷新机制

**问题**：前端没有在Token即将过期前主动刷新，导致：
- 用户在使用过程中，Token突然过期
- 必须等到下一个请求返回401时才能刷新
- 如果refreshToken也过期，就必须重新登录

## 可能的原因

### 1. AccessToken过期时间过短
- 如果 `accessTokenValiditySeconds` 设置过小（如30分钟），用户长时间使用后Token会过期
- 需要检查数据库配置

### 2. RefreshToken过期时间过短
- 如果 `refreshTokenValiditySeconds` 设置过小（如1天），用户几天不登录后refreshToken会过期
- 需要检查数据库配置

### 3. 缺少主动刷新机制
- 前端只在收到401时才刷新，没有在Token过期前主动刷新
- 如果用户长时间不操作，Token过期后第一个请求会失败

### 4. 多个Axios实例可能未统一处理
- 项目中存在多个axios实例（`authAxios`, `templateAxios`, 默认`axios`）
- 需要确保所有实例都正确配置了401处理

### 5. Token过期时间解析问题
- 前端需要正确解析后端返回的 `expiresTime` 格式
- 后端返回的是 `LocalDateTime` 格式（如：`2024-12-19T10:30:00`）

## 解决方案

### 方案1：添加主动刷新机制（推荐）

在Token即将过期前（如过期前5分钟）主动刷新：

```typescript
// 在 tokenRefreshManager.ts 中添加
let refreshTimer: NodeJS.Timeout | null = null

// 启动定时刷新
function startAutoRefresh() {
    // 清除旧的定时器
    if (refreshTimer) {
        clearInterval(refreshTimer)
    }
    
    // 每5分钟检查一次Token是否即将过期
    refreshTimer = setInterval(async () => {
        const expiresTime = localStorage.getItem(LocalStorageKey.expiresTimeKey)
        if (!expiresTime) return
        
        const expiresTimestamp = parseExpiresTime(expiresTime)
        if (expiresTimestamp === null) return
        
        const now = Date.now()
        const timeUntilExpiry = expiresTimestamp - now
        
        // 如果Token在5分钟内过期，主动刷新
        if (timeUntilExpiry > 0 && timeUntilExpiry < 5 * 60 * 1000) {
            console.log('Token即将过期，主动刷新...')
            try {
                const refreshTokenRes = await refreshToken()
                if (refreshTokenRes) {
                    saveTokens(refreshTokenRes.accessToken, refreshTokenRes.refreshToken, refreshTokenRes.expiresTime)
                    console.log('Token主动刷新成功')
                }
            } catch (error) {
                console.error('Token主动刷新失败:', error)
            }
        }
    }, 5 * 60 * 1000) // 每5分钟检查一次
}

// 在登录成功后启动
export function startTokenAutoRefresh() {
    startAutoRefresh()
}

// 在登出时停止
export function stopTokenAutoRefresh() {
    if (refreshTimer) {
        clearInterval(refreshTimer)
        refreshTimer = null
    }
}
```

### 方案2：检查并调整后端Token过期时间配置

**检查数据库**：
```sql
SELECT 
    client_id,
    name,
    access_token_validity_seconds,
    refresh_token_validity_seconds
FROM system_oauth2_client
WHERE client_id = 'default';
```

**建议配置**：
- `accessTokenValiditySeconds`: 7200（2小时）
- `refreshTokenValiditySeconds`: 2592000（30天）

### 方案3：优化错误处理

确保所有axios实例都正确处理401错误：

```typescript
// 确保所有axios实例都使用统一的401处理
authAxios.interceptors.response.use(
    (response) => response.data,
    async (error) => {
        if (error.response?.status === 401) {
            const { handle401Error } = await import('@/utils/tokenRefreshManager')
            return await handle401Error(error.config, authAxios)
        }
        return Promise.reject(error)
    }
)
```

### 方案4：添加Token过期时间检查

在请求拦截器中检查Token是否即将过期：

```typescript
// 在请求拦截器中添加
authAxios.interceptors.request.use(async (config) => {
    const expiresTime = localStorage.getItem(LocalStorageKey.expiresTimeKey)
    if (expiresTime) {
        const expiresTimestamp = parseExpiresTime(expiresTime)
        if (expiresTimestamp) {
            const now = Date.now()
            const timeUntilExpiry = expiresTimestamp - now
            
            // 如果Token在1分钟内过期，先刷新
            if (timeUntilExpiry > 0 && timeUntilExpiry < 60 * 1000) {
                if (!isRefreshing) {
                    try {
                        const refreshTokenRes = await refreshToken()
                        if (refreshTokenRes) {
                            saveTokens(refreshTokenRes.accessToken, refreshTokenRes.refreshToken, refreshTokenRes.expiresTime)
                        }
                    } catch (error) {
                        console.error('预刷新Token失败:', error)
                    }
                }
            }
        }
    }
    
    // 设置Authorization头
    setAuthHeader(config)
    return config
})
```

## 实施建议

### 优先级1：立即实施
1. ✅ **检查数据库Token过期时间配置**
   - 确认 `accessTokenValiditySeconds` 和 `refreshTokenValiditySeconds` 的值
   - 如果过短，建议调整为合理值

2. ✅ **添加主动刷新机制**
   - 在Token过期前5分钟主动刷新
   - 避免用户在使用过程中突然需要登录

### 优先级2：优化改进
3. ✅ **优化请求拦截器**
   - 在请求前检查Token是否即将过期
   - 如果即将过期，先刷新再发送请求

4. ✅ **统一所有Axios实例的401处理**
   - 确保 `authAxios`、`templateAxios` 等所有实例都正确处理401

### 优先级3：监控和日志
5. ✅ **添加Token刷新日志**
   - 记录每次Token刷新的时间、原因（主动/被动）
   - 便于排查问题

6. ✅ **添加Token过期时间显示**
   - 在开发环境下显示Token剩余有效时间
   - 便于调试

## 检查清单

- [ ] 检查数据库 `system_oauth2_client` 表的Token过期时间配置
- [ ] 实施主动刷新机制（Token过期前5分钟刷新）
- [ ] 优化请求拦截器（请求前检查Token是否即将过期）
- [ ] 确保所有axios实例都正确处理401错误
- [ ] 添加Token刷新日志
- [ ] 测试长时间使用场景（2小时以上）
- [ ] 测试多标签页场景（确保Token同步）

## 调试方法

### 1. 检查Token过期时间
```javascript
// 在浏览器控制台执行
const expiresTime = localStorage.getItem('xp_expires_time')
console.log('Token过期时间:', expiresTime)
const expiresTimestamp = new Date(expiresTime).getTime()
const now = Date.now()
const timeUntilExpiry = expiresTimestamp - now
console.log('距离过期还有:', Math.floor(timeUntilExpiry / 1000 / 60), '分钟')
```

### 2. 检查后端Token配置
```sql
-- 查看默认客户端的Token配置
SELECT 
    client_id,
    name,
    access_token_validity_seconds / 3600 as access_token_hours,
    refresh_token_validity_seconds / 86400 as refresh_token_days
FROM system_oauth2_client
WHERE client_id = 'default';
```

### 3. 查看Token刷新日志
- 打开浏览器控制台
- 查看 `tokenRefreshManager.ts` 中的 `console.log` 输出
- 关注 "开始刷新Token"、"Token刷新成功" 等日志

## 最新修复（2024-12-19）

### 问题诊断
根据错误日志和后端接口定义，Token刷新接口调用失败，导致频繁登录问题。

**根本原因**：
后端接口 `/system/auth/refresh-token` 使用 `@RequestParam` 接收参数，期望接收**查询参数**或**表单数据**，而不是JSON请求体。

**错误日志分析**：
1. 方式1失败：`Cannot convert undefined or null to object` - axios配置问题
2. 方式2请求成功，但后端返回：`{code: 400, msg: '请求参数缺失:refreshToken'}` - 使用JSON请求体，后端无法接收

### 修复内容

#### 1. 修复刷新Token接口调用方式（最终修复）
**问题**：
- 之前使用JSON请求体发送参数，但后端接口使用 `@RequestParam`，无法接收JSON格式
- 后端期望查询参数或表单数据格式

**解决方案**：根据后端接口要求，实现2种正确的调用方式：
- **方式1（推荐）**：使用查询参数（URL params）- 使用 axios 的 `params` 配置
  ```javascript
  axios.post(url, null, {
    params: { refreshToken: refreshTokenValue }
  })
  ```
- **方式2（备选）**：使用表单数据（application/x-www-form-urlencoded）
  ```javascript
  const formData = new URLSearchParams()
  formData.append('refreshToken', refreshTokenValue)
  axios.post(url, formData, {
    headers: { 'Content-Type': 'application/x-www-form-urlencoded' }
  })
  ```

代码会优先尝试方式1（查询参数），如果失败则尝试方式2（表单数据）。每种方式都会检查响应数据的有效性（code === 0 且 data 存在）。

#### 2. 同步更新 login-test.html
更新测试页面中的刷新Token实现，使用正确的查询参数方式。

#### 3. 增强错误日志
添加了详细的错误日志，包括：
- 每种尝试方式的详细错误信息（status, code, msg, data）
- 完整的错误对象和响应头信息
- 请求配置信息

这有助于快速诊断刷新失败的原因。

#### 3. 代码位置
修改文件：`src/utils/tokenRefreshManager.ts`
- `refreshToken()` 函数（第157-350行）

### 测试建议

1. **测试刷新Token功能**
   - 打开浏览器控制台
   - 等待Token过期或手动触发401错误
   - 观察控制台日志，查看哪种方式成功
   - 如果所有方式都失败，查看详细的错误信息

2. **检查后端接口**
   - 确认后端 `/system/auth/refresh-token` 接口的实际实现
   - 确认接口需要的参数格式（Authorization头、请求体、URL参数）
   - 确认是否需要clientId参数

3. **数据库配置检查**
   ```sql
   -- 查看默认客户端的Token配置
   SELECT 
       client_id,
       name,
       access_token_validity_seconds / 3600 as access_token_hours,
       refresh_token_validity_seconds / 86400 as refresh_token_days
   FROM system_oauth2_client
   WHERE client_id = 'default';
   ```
   
   建议配置：
   - `accessTokenValiditySeconds`: 7200（2小时）
   - `refreshTokenValiditySeconds`: 2592000（30天）

### 下一步

如果问题仍然存在，请：
1. 查看浏览器控制台的详细错误日志
2. 确认后端刷新接口的实际实现和参数要求
3. 根据错误日志调整前端调用方式

## 总结

频繁登录问题的主要原因可能是：
1. **Token过期时间配置过短**
2. **缺少主动刷新机制**（已在之前修复中添加）
3. **刷新Token接口调用方式不正确**（本次修复）
4. **多个axios实例可能未统一处理401**

已实施的修复：
1. ✅ 添加主动刷新机制（Token过期前5分钟刷新）
2. ✅ 修复刷新Token接口调用方式（多种方式自动回退）
3. ✅ 增强错误日志（便于诊断问题）

待检查：
1. ⏳ 检查并调整后端Token过期时间配置
2. ⏳ 确认后端刷新接口的实际实现和参数要求
3. ⏳ 测试刷新Token功能是否正常工作

